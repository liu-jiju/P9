
unkonw：只是一个赋值

(1) 任何类型的值都可以赋值给 unknown 类型
(2) 如果没有类型断言或基于控制流的类型细化时 unknown 不可以赋值给其它类型，此时它只能赋值给 unknown 和 any 类型
(3) 如果没有类型断言或基于控制流的类型细化，则不能在它上面进行任何操作
(4) unknown 与任何其它类型组成的交叉类型，最后都等于其它类型
(5) unknown 与任何其它类型组成的联合类型，都等于 unknown 类型，但只有any例外，unknown与any组成的联合类型等于any)
(6) never 类型是 unknown 的子类型
(7) keyof unknown 等于类型 never
(8) 只能对 unknown 进行等或不等操作，不能进行其它操作
(9) unknown 类型的值不能访问其属性、作为函数调用和作为类创建实例
(10) 使用映射类型时如果遍历的是 unknown 类型，则不会映射任何属性

装饰器：
定义: 装饰器是一种新的声明，它能够作用于**类声明、方法、访问符、属性和参数**上
符号: @xxx(自定义的函数名称)
 注意点: 要注意**装饰器要紧挨着要修饰的内容的前面**

装饰器工厂：
闭包的概念是: 内部函数可以返回外部的函数,内部可以调用外部的函数
装饰器工厂：也是一个函数，它的返回值是一个函数，返回的函数作为装饰器的调用函数。
	   如果使用装饰器工厂，那么在使用的时候，就要加上函数调用
装饰器组合：
装饰器可以组合，也就是对于同一个目标，引用多个装饰器

类装饰器：
类装饰器在类声明之前声明，要记着装饰器要紧挨着要修饰的内容，类装饰器应用于类的声明。
类装饰器表达式会在运行时当做函数被调用，它由唯一一个参数，就是装饰的这个类。

方法装饰器：
方法装饰器用来处理类中方法，它可以处理方法的属性描述符，
可以处理方法定义。方法装饰器在运行时也是被当做函数调用，含 3 个参数：
   	装饰静态成员时是类的构造函数，装饰实例成员时是类的原型对象；
	成员的名字；
	成员的属性描述符。

访问装饰器：访问器也就是我们之前讲过的 set 和 get 方法，一个在设置属性值的时候触发，一个在获取属性值的时候触发。
属性装饰器：属性装饰器声明在属性声明之前，它有 2 个参数，和方法装饰器的前两个参数是一模一样的。
	   属性装饰器没法操作属性的属性描述符，它只能用来判断某各类中是否声明了某个名字的属性
参数装饰器：参数装饰器有 3 个参数，前两个和方法装饰器的前两个参数一模一样
	    装饰静态成员时是类的构造函数，装饰实例成员时是类的原型对象；
	    成员的名字；
	    参数在函数参数列表中的索引。








